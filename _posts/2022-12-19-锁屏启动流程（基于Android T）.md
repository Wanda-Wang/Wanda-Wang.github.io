---
title: 锁屏启动流程（Android T）
author: wanda
date: 2022-12-19 14:10:00 +0800
categories: [Blogging, Tutorial, Android]
tags: [SystemUI]
render_with_liquid: false
---

# 锁屏启动流程（基于Android T）

锁屏开机大致分为两部分：第一部分是KeyguardViewMediator的启动；第二部分是从WindowManagerService开始，处理锁屏显示等流程。![1](https://wanda-wang.github.io/assets/img/article/two.jpg)

## 一、KeyguardViewMediator的启动

### 1. 整体流程概要

![](https://wanda-wang.github.io/assets/img/article/KeyguardViewMediator的启动.jpg)

KeyguardViewMediator在SystemUI中启动，而SystemUI是由SystemServer启动，而SystemServer是由Zygote fork生成的，进程名为`system_server`，该进程承载着framework的核心服务。而Zygote进程是Android层面的第一个进程，俗称进程孵化器，Android中所有进程都是通过Zygote fork（分岔）出来的，而Zygote进程是在开机时Linux创建的第一个用户空间进程（init进程）创建的。

> 搬砖：Zygote 和 SystemServer学习文档：[浅谈 Zygote 和 SystemServer](https://juejin.cn/post/6873066972616065038)

### 2. SystemUI启动到KeyguardViewMediator具体流程

![](https://wanda-wang.github.io/assets/img/article/SystemUI启动到KeyguardViewMediator具体流程.jpg)

其中上图和2. 1）-2. 2）也是SystemUI中其它各模块的启动流程。

可以根据日志的流程分析启动的流程：开机自己检索关键字（SystemUIService|SystemServer）



#### **2.1 SystemServer->SystemUI**

从SystemServer的main()方法开始梳理，如果想知道哪儿调用的main()，可以看“三、Q&A-1. SystemServer的启动”中的文档。

##### **2.1.1 com.android.server.SystemServer#main**

```java
/**
 * The main entry point from zygote.
 */
public static void main(String[] args) {
    new SystemServer().run();
}
```
{: file='_sass/jekyll-theme-chirpy.scss'}

**2.1.2 在main()中调用了SystemServer#run**

SystemServer#run负责启动系统的各种服务。

```java
private void run() {
//此处源码较多，省略
//......
// Start services.
try {
    t.traceBegin("StartServices");
    startBootstrapServices(t);
    startCoreServices(t);
    startOtherServices(t);
    startApexServices(t);
} catch (Throwable ex) {
    Slog.e("System", "");
    Slog.e("System", " Failure starting system services", ex);
    throw ex;
} finally {
    t.traceEnd(); // StartServices
}
//此处源码较多，省略
//......
}
```
{: file='_sass/jekyll-theme-chirpy.scss'}

##### **2.1.3 run()中调用了SystemServer#startOtherServices**

startOtherServices()启动、初始化了Android常用的许许多多服务，比如WindowManagerService：

```java
//此处源码较多，省略
//......
t.traceBegin("StartWindowManagerService");
// WMS needs sensor service ready
mSystemServiceManager.startBootPhase(t, SystemService.PHASE_WAIT_FOR_SENSOR_SERVICE);
wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,
        new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager);
ServiceManager.addService(Context.WINDOW_SERVICE, wm, /* allowIsolated= / false,
        DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO);
ServiceManager.addService(Context.INPUT_SERVICE, inputManager,
        / allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL);
t.traceEnd();

t.traceBegin("SetWindowManagerService");
mActivityManagerService.setWindowManager(wm);
t.traceEnd();

t.traceBegin("WindowManagerServiceOnInitReady");
wm.onInitReady();
t.traceEnd();
//此处源码较多，省略
//......
```
{: file='_sass/jekyll-theme-chirpy.scss'}

##### **2.1.4 SystemServer#startSystemUi启动SystemUIService**

在startOtherServices()结尾处，才调用SystemServer#startSystemUi启动SystemUIService

```Java
private void startOtherServices(@NonNull TimingsTraceAndSlog t) {
    t.traceBegin("startOtherServices");
    //此处省略上千行源码
    //......
    t.traceBegin("StartSystemUI");
    try {
        startSystemUi(context, windowManagerF);
    } catch (Throwable e) {
        reportWtf("starting System UI", e);
    }
    t.traceEnd();

    t.traceEnd(); // startOtherServices
}
```

这里原因我理解是SystemUI依赖上述启动的Service，比如SystemUI启动后，需要WindowManagerService绑定锁屏。

##### **2.1.5 startSystemUi()启动SystemUiService**

```Java
private static void startSystemUi(Context context, WindowManagerService windowManager) {
    PackageManagerInternal pm = LocalServices.getService(PackageManagerInternal.class);
    Intent intent = new Intent();
    intent.setComponent(pm.getSystemUiServiceComponent());
    intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);
    //Slog.d(TAG, "Starting service: " + intent);
    context.startServiceAsUser(intent, UserHandle.SYSTEM);
    windowManager.onSystemUiStarted();
}
<!-- SystemUi service component -->
<string name="config_systemUIServiceComponent" translatable="false"
        >com.android.systemui/com.android.systemui.SystemUIService</string>
```

startSystemUi()不仅启动了SystemUIService，还调用了WindowManagerService的onSystemUiStarted()，**在onSystemUiStarted()中绑定了锁屏！（第二部分再分析）**

```Java
//com.android.server.policy.PhoneWindowManager#onSystemUiStarted
@Override
public void onSystemUiStarted() {
    bindKeyguard();
}
```

> **小tips**
>
> Q: SystemServer启动了这么多的服务，要怎么看启动一个服务有哪些具体操作？
>
> A: 看TimingsTraceAndSlog即可，以TimingsTraceAndSlog.traceBegin("")开始，以TimingsTraceAndSlog.traceEnd()结束，中间是具体操作。在logcat中也可以检索关键字`SystemServerTiming`。
{: .prompt-info }

#### **2.2 SystemUI->KeyguardViewMediator**

上文说了SystemServer启动SystemUIService，但在SystemUIService#onCreate前，SystemUIApplication已经创建了。

日志中：

```Apache
2022-10-13 17:45:05.205 2388-2388/com.android.systemui V/SystemUIService: SystemUIApplication constructed.
2022-10-13 17:45:06.153 2388-2388/com.android.systemui V/SystemUIService: SystemUIApplication created.
2022-10-13 17:45:06.166 2388-2388/com.android.systemui I/SystemUIService: SystemUIApplication UserHandle.SYSTEM Found SurfaceFlinger's GPU Priority: 13143
2022-10-13 17:45:06.167 2388-2388/com.android.systemui I/SystemUIService: Setting SysUI's GPU Context priority to: 12545
2022-10-13 17:45:07.732 1128-1128/system_process I/SystemServerTiming: StartSystemUI
2022-10-13 17:45:07.765 2388-2388/com.android.systemui D/wanda: SystemUIService onCreate: 
2022-10-13 17:45:07.765 2388-2388/com.android.systemui D/wanda: SystemUIFactory getSystemUIServiceComponents: 
        at com.android.systemui.SystemUIService.onCreate(SystemUIService.java:70)
2022-10-13 17:45:07.767 2388-2388/com.android.systemui V/SystemUIService: Starting SystemUI services for user 0.
2022-10-13 17:45:07.774 1128-1128/system_process D/SystemServerTiming: StartSystemUI took to complete: 42ms
```

SystemUIApplication已经构造：“SystemUIApplication constructed”，而后SystemServer才startSystemUI：“SystemServerTiming: StartSystemUI”。

所以还有SystemUIApplication创建流程需要分析。

1. ##### **SystemUIApplication的创建**

暂时无法在飞书文档外展示此内容

1. ###### **SystemUI清单文件中**

```XML
<application
    android:name=".SystemUIApplication"
    ......
    android:appComponentFactory=".SystemUIAppComponentFactory">
    ......
</application>
```

清单文件中属性appComponentFactory的值是.SystemUIAppComponentFactory，PMS会将该属性解析到appInfo.appComponentFactory中。

1. ###### **ActivityThread**

| android.app.ActivityThread#handleBindApplication`@UnsupportedAppUsage private void handleBindApplication(AppBindData data) {    Application app;    //... ...    try {        *// If the app is being launched for full backup or restore, bring it up in*        *// a restricted environment with the base application class.*        app = data.info.makeApplicationInner(data.restrictedBackupMode, null);    //... ...    try {        mInstrumentation.callApplicationOnCreate(app);    } catch (Exception e) {        if (!mInstrumentation.onException(app, e)) {            throw new RuntimeException(              "Unable to create application " + app.getClass().getName()              + ": " + e.toString(), e);            }        }    } finally {    //... ...    } }` | @UnsupportedAppUsage不支持外部应用使用被该注解声明的method or field。 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| app = data.info.**makeApplicationInner**(data.restrictedBackupMode, null);调用了android.app.LoadedApk#makeApplicationInner对应顺序图，向下追溯最终会调用SystemUIApplication的构造函数，获取到SystemUIApplication实例化对象并赋值给app变量。 |                                                              |
| mInstrumentation.callApplicationOnCreate(app);调用android.app.Instrumentation#callApplicationOnCreate，将上一步**makeApplicationInner**获取到的SystemUIApplication实例传值到Instrumentation中，调用SystemUIApplication的onCreate() |                                                              |

1. ###### **LoadedApk**

| `*/*** ** Local state maintained about a currently loaded .apk.* *** *@hide* **/* public final class LoadedApk {    private Application makeApplicationInner(boolean forceDefaultAppClass,        Instrumentation instrumentation, boolean allowDuplicateInstances) {            //... ...    Application app = null;    try {    //... ...        app = mActivityThread.mInstrumentation.newApplication(                cl, appClass, appContext);    //... ...    } catch (Exception e) {        if (!mActivityThread.mInstrumentation.onException(app, e)) {            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);            throw new RuntimeException(                "Unable to instantiate application " + appClass                + " package " + mPackageName + ": " + e.toString(), e);        }    }    mActivityThread.mAllApplications.add(app);    mApplication = app;    // ... ...    return app;    } }` | app = mActivityThread.mInstrumentation.newApplication(                cl, appClass, appContext);调用android.app.Instrumentation#newApplication(ClassLoader, String, Context)，获取SystemUIApplication实例 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

以下在分析在4. Instrumentation后再看：

| `public AppComponentFactory getAppFactory() {    return mAppComponentFactory; } private AppComponentFactory createAppFactory(ApplicationInfo appInfo, ClassLoader cl) {    if (mIncludeCode && appInfo.appComponentFactory != null && cl != null) {        try {            return (AppComponentFactory)                    cl.loadClass(appInfo.appComponentFactory).newInstance();        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {            Slog.e(TAG, "Unable to instantiate appComponentFactory", e);        }    }    return AppComponentFactory.DEFAULT; }` | return (AppComponentFactory) cl.loadClass(appInfo.appComponentFactory).newInstance();通过反射ClassLoader.loadClass()获取ApplicationInfo实例的appComponentFactory参数，创建appComponentFactory的实例。在ApplicationInfo类中有成员变量appComponentFactory和清单文件属性也对应上了！`*/*** ** The factory of this package, as specified by the <manifest>* ** tag's {**@link* *android.R.styleable#AndroidManifestApplication_appComponentFactory}* ** attribute.* **/* public String appComponentFactory;` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

1. ###### **Instrumentation**

| `*/*** ** Perform instantiation of the process's {**@link* *Application} object.  The* ** default implementation provides the normal system behavior.* ***  *** *@param* *cl The ClassLoader with which to instantiate the object.* *** *@param* *className The name of the class implementing the Application* **                  object.* *** *@param* *context The context to initialize the application with* ***  *** *@return* *The newly instantiated Application object.* **/* public Application newApplication(ClassLoader cl, String className, Context context)        throws InstantiationException, IllegalAccessException,         ClassNotFoundException {    Application app = getFactory(context.getPackageName())            .instantiateApplication(cl, className);    app.attach(context);    return app; }` | getFactory(String pkg)根据包名获取factory：`private AppComponentFactory getFactory(String pkg) {    if (pkg == null) {        Log.e(TAG, "No pkg specified, disabling AppComponentFactory");        return AppComponentFactory.DEFAULT;    }    if (mThread == null) {        Log.e(TAG, "Uninitialized ActivityThread, likely app-created Instrumentation,"                + " disabling AppComponentFactory", new Throwable());        return AppComponentFactory.DEFAULT;    }    LoadedApk apk = mThread.peekPackageInfo(pkg, true);    *// This is in the case of starting up "android".*    if (apk == null) apk = mThread.getSystemContext().mPackageInfo;    return apk.getAppFactory(); }`最终还是调用了LoadedApk中的getAppFactory()，返回3看一下是如何获取到factory的。 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| .instantiateApplication(cl, className);所以最后调用走到了清单文件加的属性android:appComponentFactory=".SystemUIAppComponentFactory"中，先调用instantiateApplication()。因为SystemUIAppComponentFactory没有重写instantiateApplication，且它继承自androidx的AppComponentFactory，所以先看AppComponentFactory |                                                              |

1. ###### **androidx.core.app.AppComponentFactory**

| `    /**     * @see #instantiateApplicationCompat     */    @NonNull    @Override    public final Application instantiateApplication(            @NonNull ClassLoader cl, @NonNull String className)            throws InstantiationException, IllegalAccessException, ClassNotFoundException {        return checkCompatWrapper(instantiateApplicationCompat(cl, className));    }``    /**     * Allows application to override the creation of the application object. This can be used to     * perform things such as dependency injection or class loader changes to these     * classes.     * <p>     * This method is only intended to provide a hook for instantiation. It does not provide     * earlier access to the Application object. The returned object will not be initialized     * as a Context yet and should not be used to interact with other android APIs.     *     * @param cl        The default classloader to use for instantiation.     * @param className The class to be instantiated.     */    public @NonNull Application instantiateApplicationCompat(@NonNull ClassLoader cl,            @NonNull String className)            throws InstantiationException, IllegalAccessException, ClassNotFoundException {        try {            return Class.forName(className, false, cl).asSubclass(Application.class)                    .getDeclaredConstructor().newInstance();        } catch (InvocationTargetException | NoSuchMethodException e) {            throw new RuntimeException("Couldn't call constructor", e);        }    }` | return Class.forName(className, false, cl).asSubclass(Application.class).getDeclaredConstructor().newInstance();instantiateApplication中调了instantiateApplicationCompat，在instantiateApplicationCompat中创建了SystemUIApplication实例，所以在这里SystemUIApplication构造函数被调用：`2022-10-13 17:45:05.205 2388-2388/com.android.systemui V/SystemUIService: SystemUIApplication constructed.` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

1. ###### **SystemUIAppComponentFactory**

| com.android.systemui.SystemUIAppComponentFactory#instantiateApplicationCompat`@NonNull @Override public Application instantiateApplicationCompat(        @NonNull ClassLoader cl, @NonNull String className)        throws InstantiationException, IllegalAccessException, ClassNotFoundException {    Application app = super.instantiateApplicationCompat(cl, className);    if (app instanceof ContextInitializer) {        ((ContextInitializer) app).setContextAvailableCallback(                context -> {                    SystemUIFactory.*createFromConfig*(context);                    SystemUIFactory.*getInstance*().getSysUIComponent().inject(                            SystemUIAppComponentFactory.this);                }        );    }     return app; }` | super.instantiateApplicationCompat父类androidx.core.app.AppComponentFactory，创建SystemUIApplication实例 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| setContextAvailableCallback*createFromConfig：*通过反射创建SystemUIFactory实例获取SystemUIFactory实例，通过dagger注入SystemUIAppComponentFactorycom.android.systemui.SystemUIApplication#onCreate中调用ContextAvailable回调：`@Override public void onCreate() {    super.onCreate();    //... ...    mContextAvailableCallback.onContextAvailable(this);    //... ... }` |                                                              |

1. ##### **SystemUI->KeyguardViewMediator**

在  [2.1 SystemServer->SystemUI](https://xiaomi.f.mioffice.cn/docs/dock4C2GTnwVGFUN0sbazRZurri#QmBq3z)的最后，[startSystemUi()启动SystemUiService](https://xiaomi.f.mioffice.cn/docs/dock4C2GTnwVGFUN0sbazRZurri#esXaeO)。

1. ###### **SystemUIService**

| com.android.systemui.SystemUIService#onCreate`@Override public void onCreate() {    super.onCreate();    *// Start all of SystemUI*    ((SystemUIApplication) getApplication()).startServicesIfNeeded();     *// Finish initializing dump logic*    mLogBufferFreezer.attach(mBroadcastDispatcher);     *// If configured, set up a battery notification*    if (getResources().getBoolean(R.bool.config_showNotificationForUnknownBatteryState)) {        mBatteryStateNotifier.startListening();    }     *// For debugging RescueParty*    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean("debug.crash_sysui", false)) {        throw new RuntimeException();    }     if (Build.IS_DEBUGGABLE) {        *// b/71353150 - looking for leaked binder proxies*        BinderInternal.nSetBinderProxyCountEnabled(true);        BinderInternal.nSetBinderProxyCountWatermarks(1000,900);        BinderInternal.setBinderProxyCountCallback(                new BinderInternal.BinderProxyLimitListener() {                    @Override                    public void onLimitReached(int uid) {                        Slog.w(SystemUIApplication.TAG,                                "uid " + uid + " sent too many Binder proxies to uid "                                + Process.myUid());                    }                }, mMainHandler);    }     *// Bind the dump service so we can dump extra info during a bug report*    startServiceAsUser(            new Intent(getApplicationContext(), SystemUIAuxiliaryDumpService.class),            UserHandle.SYSTEM); }` | startServicesIfNeeded调用SystemUIApplication的startServicesIfNeeded()，启动SystemUI |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

1. ###### **SystemUIApplication**

| com.android.systemui.SystemUIApplication#startServicesIfNeeded()`*/*** ** Makes sure that all the SystemUI services are running. If they are already running, this is a* ** no-op. This is needed to conditinally start all the services, as we only need to have it in* ** the main process.* ** <p>This method must only be called from the main thread.</p>* **/* public void startServicesIfNeeded() {    String[] names = SystemUIFactory.getInstance().getSystemUIServiceComponents(getResources());    startServicesIfNeeded(*/\* metricsPrefix= \*/* "StartServices", names); }`com.android.systemui.SystemUIApplication#startServicesIfNeeded(String, String[])`private void startServicesIfNeeded(String metricsPrefix, String[] services) {    if (mServicesStarted) {        return;    }    mServices = new SystemUI[services.length];     if (!mBootCompleteCache.isBootComplete()) {        *// check to see if maybe it was already completed long before we began*        *// see ActivityManagerService.finishBooting()*        if ("1".equals(SystemProperties.get("sys.boot_completed"))) {            mBootCompleteCache.setBootComplete();            if (DEBUG) {                Log.v(TAG, "BOOT_COMPLETED was already sent");            }        }    }     final DumpManager dumpManager = mSysUIComponent.createDumpManager();     Log.v(TAG, "Starting SystemUI services for user " +            Process.myUserHandle().getIdentifier() + ".");    TimingsTraceLog log = new TimingsTraceLog("SystemUIBootTiming",            Trace.TRACE_TAG_APP);    log.traceBegin(metricsPrefix);    final int N = services.length;    for (int i = 0; i < N; i++) {        String clsName = services[i];        if (DEBUG) Log.d(TAG, "loading: " + clsName);        log.traceBegin(metricsPrefix + clsName);        long ti = System.currentTimeMillis();        try {            SystemUI obj = mComponentHelper.resolveSystemUI(clsName);            if (obj == null) {                Constructor constructor = Class.forName(clsName).getConstructor(Context.class);                obj = (SystemUI) constructor.newInstance(this);            }            mServices[i] = obj;        } catch (ClassNotFoundException                | NoSuchMethodException                | IllegalAccessException                | InstantiationException                | InvocationTargetException ex) {            throw new RuntimeException(ex);        }         if (DEBUG) Log.d(TAG, "running: " + mServices[i]);        mServices[i].start();        log.traceEnd();         *// Warn if initialization of component takes too long*        ti = System.currentTimeMillis() - ti;        if (ti > 1000) {            Log.w(TAG, "Initialization of " + clsName + " took " + ti + " ms");        }        if (mBootCompleteCache.isBootComplete()) {            mServices[i].onBootCompleted();        }         dumpManager.registerDumpable(mServices[i].getClass().getName(), mServices[i]);    }    mSysUIComponent.getInitController().executePostInitTasks();    log.traceEnd();     mServicesStarted = true;    FeatureOptions.sShouldShowUI = true; }` | startServicesIfNeeded只能在主线程中调用，启动SystemUI中必要服务。 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| getSystemUIServiceComponents从资源文件中获取需要启动的SystemUI组件列表：`//com.android.systemui.SystemUIFactory#getSystemUIServiceComponents */*** ** Returns the list of system UI components that should be started.* **/* public String[] getSystemUIServiceComponents(Resources resources) {    return resources.getStringArray(R.array.config_systemUIServiceComponents); }``*<!-- res/values/config.xml:32 -->* *<!-- SystemUI Services: The classes of the stuff to start. -->* <string-array name="config_systemUIServiceComponents" translatable="false">    <item>com.android.systemui.util.NotificationChannels</item>    <item>com.android.systemui.keyguard.KeyguardViewMediator</item>    <item>com.android.systemui.recents.Recents</item>    <item>com.android.systemui.volume.VolumeUI</item>    <item>com.android.systemui.statusbar.phone.StatusBar</item>    <item>com.android.systemui.usb.StorageNotification</item>    <item>com.android.systemui.power.PowerUI</item>    <item>com.android.systemui.media.RingtonePlayer</item>    <item>com.android.systemui.keyboard.KeyboardUI</item>    <item>com.android.systemui.shortcut.ShortcutKeyDispatcher</item>    <item>@string/config_systemUIVendorServiceComponent</item>    <item>com.android.systemui.util.leak.GarbageMonitor$Service</item>    <item>com.android.systemui.LatencyTester</item>    <item>com.android.systemui.globalactions.GlobalActionsComponent</item>    <item>com.android.systemui.ScreenDecorations</item>    <item>com.android.systemui.biometrics.AuthController</item>    <item>com.android.systemui.SliceBroadcastRelayHandler</item>    <item>com.android.systemui.statusbar.notification.InstantAppNotifier</item>    <item>com.android.systemui.theme.ThemeOverlayController</item>    <item>com.android.systemui.accessibility.WindowMagnification</item>    <item>com.android.systemui.accessibility.SystemActions</item>    <item>com.android.systemui.toast.ToastUI</item>    <item>com.android.systemui.wmshell.WMShell</item> </string-array>` |                                                              |
| startServicesIfNeeded(String, String[])mServices：` */*** ** Hold a reference on the stuff we start.* **/* private SystemUI[] mServices;`mServices是SystemUI数组，而以上所有要启动的组件都继承了SystemUI类，所以mServices用来添加各组件实例，用来启动各组件。主要代码在for循环中：SystemUI obj = mComponentHelper.resolveSystemUI(clsName);string-array中存的是各组件类名，resolveSystemUI中先通过类名在Dagger中查找实例（解析依赖），没找到就返回null：`@Override public SystemUI resolveSystemUI(String className) {    return resolve(className, mSystemUICreators); } private <T> T resolve(String className, Map<Class<?>, Provider<T>> creators) {    try {        Class<?> clazz = Class.forName(className);        Provider<T> provider = creators.get(clazz);        return provider == null ? null : provider.get();    } catch (ClassNotFoundException e) {        return null;    } }`如果Dagger没找到实例，就反射创建：`if (obj == null) {   Constructor constructor = Class.forName(clsName).getConstructor(Context.class);   obj = (SystemUI) constructor.newInstance(this); }`**最后mServices[i].start()启动各组件** |                                                              |

1. ###### **Android T上的不同**

Android T上不再通过数组config_systemUIServiceComponents来获取各组件，而是全部通过dagger获取。

| com.android.systemui.SystemUIApplication#startServicesIfNeeded()`*/*** ** Makes sure that all the SystemUI services are running. If they are already running, this is a* ** no-op. This is needed to conditinally start all the services, as we only need to have it in* ** the main process.* ** <p>This method must only be called from the main thread.</p>* **/* public void startServicesIfNeeded() {    final String vendorComponent = SystemUIFactory.*getInstance*()            .getVendorComponent(getResources());     *// Sort the startables so that we get a deterministic ordering.*    *//* *TODO:* *make #start idempotent and require users of CoreStartable to call it.*    Map<Class<?>, Provider<CoreStartable>> sortedStartables = new TreeMap<>(            Comparator.*comparing*(Class::getName));    sortedStartables.putAll(SystemUIFactory.*getInstance*().getStartableComponents());    sortedStartables.putAll(SystemUIFactory.*getInstance*().getStartableComponentsPerUser());    startServicesIfNeeded(            sortedStartables, "StartServices", vendorComponent); }` | getStartableComponents`//com.android.systemui.SystemUIFactory#getStartableComponents */*** ** Returns the list of {**@link* *CoreStartable} components that should be started at startup.* **/* public Map<Class<?>, Provider<CoreStartable>> getStartableComponents() {    return mSysUIComponent.getStartables(); }``//com.android.systemui.dagger.SysUIComponent#getStartables */*** ** Returns {**@link* *CoreStartable}s that should be started with the application.* **/* Map<Class<?>, Provider<CoreStartable>> getStartables();`需要启动的组件类都继承了CoreStartable且标记为需要注入。具体如何通过dagger实现各组件put进该Map中，参考[Dagger2 简介及其在SystemUI启动流程中的应用](https://xiaomi.f.mioffice.cn/docs/dock4SPHvjpUbzKlqIkgADxXqCc#UXQp6z) 三、4.2部分，在gradle编译后，会自动生成**DaggerGlobalRootComponent**类，在这个类里实现了注入。 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Provider<T>接口 Provider 用于提供类型 T 的实列。Provider 是一般情况是由注入器实现的。对于任何可注入的 T 而言，您也可以注入 Provider<T>。与直接注入 T 相比，注入 Provider<T> 使得：可以返回多个实例。实例的返回可以延迟化或可选打破循环依赖。可以在一个已知作用域的实例内查询一个更小作用域内的实例。 |                                                              |

至此，KeyguardViewMediator就启动了。

## 二、WindowManagerService处理锁屏显示流程

暂时无法在飞书文档外展示此内容

1. ### framework

1. #### WindowManagerService

| WindowManagerService#main和SystemUI启动一样，WindowManagerService也是在com.android.server.SystemServer#startOtherServices中启动，调用com.android.server.wm.WindowManagerService#mainWindowManagerService#main中创建了WindowManagerService的实例并返回 | com.android.server.**SystemServer#startOtherServices**`t.traceBegin("StartWindowManagerService"); *// WMS needs sensor service ready* mSystemServiceManager.startBootPhase(t, SystemService.PHASE_WAIT_FOR_SENSOR_SERVICE); wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,        new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager); ServiceManager.addService(Context.WINDOW_SERVICE, wm, */\* allowIsolated= \*/* false,        DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO); ServiceManager.addService(Context.INPUT_SERVICE, inputManager,        */\* allowIsolated= \*/* false, DUMP_FLAG_PRIORITY_CRITICAL); t.traceEnd();`com.android.server.wm.**WindowManagerService#main**`@VisibleForTesting public static WindowManagerService main(final Context context, final InputManagerService im,        final boolean showBootMsgs, final boolean onlyCore, WindowManagerPolicy policy,        ActivityTaskManagerService atm, DisplayWindowSettingsProvider        displayWindowSettingsProvider, Supplier<SurfaceControl.Transaction> transactionFactory,        Supplier<Surface> surfaceFactory,        Function<SurfaceSession, SurfaceControl.Builder> surfaceControlFactory) {    final WindowManagerService[] wms = new WindowManagerService[1];    DisplayThread.getHandler().runWithScissors(() ->            wms[0] = new WindowManagerService(context, im, showBootMsgs, onlyCore, policy,                    atm, displayWindowSettingsProvider, transactionFactory, surfaceFactory,                    surfaceControlFactory), 0);    return wms[0]; }` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |
| WindowManagerService#onSystemUiStartedSystemServer#startOtherServices->SystemServer#startSystemUi->WindowManagerService#onSystemUiStarted调用WindowManagerPolicy.onSystemUiStarted() | com.android.server.**SystemServer#startSystemUi**`private static void startSystemUi(Context context, WindowManagerService windowManager) {    PackageManagerInternal pm = LocalServices.getService(PackageManagerInternal.class);    Intent intent = new Intent();    intent.setComponent(pm.getSystemUiServiceComponent());    intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);    *//Slog.d(TAG, "Starting service: " + intent);*    context.startServiceAsUser(intent, UserHandle.SYSTEM);    windowManager.onSystemUiStarted(); }`com.android.server.wm.**WindowManagerService#onSystemUiStarted**`WindowManagerPolicy mPolicy; */*** ** Called when System UI has been started.* **/* public void onSystemUiStarted() {    mPolicy.onSystemUiStarted(); }` |

1. #### PhoneWindowManager

| PhoneWindowManager实现WindowManagerPolicy，所以调用走到PhoneWindowManager#onSystemUiStarted | com.android.server.policy.PhoneWindowManager#onSystemUiStarted`@Override public void onSystemUiStarted() {    bindKeyguard(); }``private void bindKeyguard() {    synchronized (mLock) {        if (mKeyguardBound) {            return;        }        mKeyguardBound = true;    }    mKeyguardDelegate.bindService(mContext); }` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

1. #### KeyguardServiceDelegate

| KeyguardServiceDelegate作为KeyguardService的委派，在binderService中绑定KeyguardService绑定KeyguardService：context.bindServiceAsUser(intent, mKeyguardConnection,             Context.BIND_AUTO_CREATE,mHandler,UserHandle.SYSTEM) | `    public void bindService(Context context) {        Intent intent = new Intent();        final Resources resources = context.getApplicationContext().getResources();         final ComponentName keyguardComponent = ComponentName.unflattenFromString(                resources.getString(com.android.internal.R.string.config_keyguardComponent));        intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);        intent.setComponent(keyguardComponent);         if (!context.bindServiceAsUser(intent, mKeyguardConnection,                Context.BIND_AUTO_CREATE, mHandler, UserHandle.SYSTEM)) {            Log.v(TAG, "*** Keyguard: can't bind to " + keyguardComponent);            mKeyguardState.showing = false;            mKeyguardState.showingAndNotOccluded = false;            mKeyguardState.secure = false;            synchronized (mKeyguardState) {                // TODO: Fix synchronisation model in this class. The other state in this class                // is at least self-healing but a race condition here can lead to the scrim being                // stuck on keyguard-less devices.                mKeyguardState.deviceHasKeyguard = false;            }        } else {            if (DEBUG) Log.v(TAG, "*** Keyguard started");        }    }``*<!-- Keyguard component -->* <string name="config_keyguardComponent" translatable="false"        >com.android.systemui/com.android.systemui.keyguard.KeyguardService</string>` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ServiceConnection绑定服务成功后回调onServiceConnected：包装KeyguardService：创建KeyguardServiceWrapper实例跨进程调用KeyguardService方法，启动锁屏界面，如onSystemReady()等 | `private final ServiceConnection mKeyguardConnection = new ServiceConnection() {        @Override        public void onServiceConnected(ComponentName name, IBinder service) {            if (DEBUG) Log.v(TAG, "*** Keyguard connected (yay!)");            mKeyguardService = new KeyguardServiceWrapper(mContext,                    IKeyguardService.Stub.asInterface(service), mCallback);            if (mKeyguardState.systemIsReady) {                // If the system is ready, it means keyguard crashed and restarted.                mKeyguardService.onSystemReady();                if (mKeyguardState.currentUser != UserHandle.USER_NULL) {                    // There has been a user switch earlier                    mKeyguardService.setCurrentUser(mKeyguardState.currentUser);                }                // This is used to hide the scrim once keyguard displays.                if (mKeyguardState.interactiveState == INTERACTIVE_STATE_AWAKE                        || mKeyguardState.interactiveState == INTERACTIVE_STATE_WAKING) {                    mKeyguardService.onStartedWakingUp(PowerManager.WAKE_REASON_UNKNOWN,                            false /* cameraGestureTriggered */);                }                if (mKeyguardState.interactiveState == INTERACTIVE_STATE_AWAKE) {                    mKeyguardService.onFinishedWakingUp();                }                if (mKeyguardState.screenState == SCREEN_STATE_ON                        || mKeyguardState.screenState == SCREEN_STATE_TURNING_ON) {                    mKeyguardService.onScreenTurningOn(                            new KeyguardShowDelegate(mDrawnListenerWhenConnect));                }                if (mKeyguardState.screenState == SCREEN_STATE_ON) {                    mKeyguardService.onScreenTurnedOn();                }                mDrawnListenerWhenConnect = null;            }            if (mKeyguardState.bootCompleted) {                mKeyguardService.onBootCompleted();            }            if (mKeyguardState.occluded) {                mKeyguardService.setOccluded(mKeyguardState.occluded, false /* animate */);            }            if (!mKeyguardState.enabled) {                mKeyguardService.setKeyguardEnabled(mKeyguardState.enabled);            }        }         @Override        public void onServiceDisconnected(ComponentName name) {            if (DEBUG) Log.v(TAG, "*** Keyguard disconnected (boo!)");            mKeyguardService = null;            mKeyguardState.reset();            mHandler.post(() -> {                try {                    ActivityTaskManager.getService().setLockScreenShown(true /* keyguardShowing */,                            false /* aodShowing */);                } catch (RemoteException e) {                    // Local call.                }            });        }    };` |

1. #### KeyguardServiceWrapper

作为KeyguardService的包装，主要用来调用KeyguardService的方法。为了保证方法和AIDL接口一致，所以实现了IKeyguardService。这样要跨进程调用任何KeyguardService的方法，都可以通过调用KeyguardServiceWrapper来实现。

1. ### SystemUI

1. #### KeyguardService

| 绑定KeyguardService 成功后，onServiceConnected中首先调用onSystemReady()。而KeyguardViewMediator是锁屏核心类，作为交互的中转类。所以WM->KeyguardService->KeyguardViewMediator中转 | `@Override *// Binder interface* public void onSystemReady() {    Trace.*beginSection*("KeyguardService.mBinder#onSystemReady");    checkPermission();    mKeyguardViewMediator.onSystemReady();    Trace.*endSection*(); }` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

1. #### KeyguardViewMediator

| doKeyguardLockeddoKeyguardLocked执行显示锁屏前的预处理操作：half-boot-to-decryption-screen state禁用锁屏锁屏被其它应用禁用，则不显示锁屏锁屏已经显示就不重复执行了是否设置sim卡密码是否已经过了开机引导是否在设置中禁用锁屏：设置中将解锁方式设置为“无”**判断完上述条件，符合条件后才能显示锁屏，执行showLocked(options)** | `    private void handleSystemReady() {        synchronized (this) {            if (DEBUG) Log.d(TAG, "onSystemReady");            mSystemReady = true;            doKeyguardLocked(null);            mUpdateMonitor.registerCallback(mUpdateCallback);            mDreamOverlayStateController.addCallback(mDreamOverlayStateCallback);        }        // Most services aren't available until the system reaches the ready state, so we        // send it here when the device first boots.        maybeSendUserPresentBroadcast();    }``    /**     * Enable the keyguard if the settings are appropriate.     */    private void doKeyguardLocked(Bundle options) {        if (KeyguardUpdateMonitor.CORE_APPS_ONLY) {            // Don't show keyguard during half-booted cryptkeeper stage.            if (DEBUG) Log.d(TAG, "doKeyguard: not showing because booting to cryptkeeper");            return;        }         // if another app is disabling us, don't show        if (!mExternallyEnabled) {            if (DEBUG) Log.d(TAG, "doKeyguard: not showing because externally disabled");             mNeedToReshowWhenReenabled = true;            return;        }         // if the keyguard is already showing, don't bother. check flags in both files        // to account for the hiding animation which results in a delay and discrepancy        // between flags        if (mShowing && mKeyguardViewControllerLazy.get().isShowing()) {            if (DEBUG) Log.d(TAG, "doKeyguard: not showing because it is already showing");            resetStateLocked();            return;        }         // In split system user mode, we never unlock system user.        if (!mustNotUnlockCurrentUser()                || !mUpdateMonitor.isDeviceProvisioned()) {             // if the setup wizard hasn't run yet, don't show            final boolean requireSim = !SystemProperties.getBoolean("keyguard.no_require_sim", false);            final boolean absent = SubscriptionManager.isValidSubscriptionId(                    mUpdateMonitor.getNextSubIdForState(TelephonyManager.SIM_STATE_ABSENT));            final boolean disabled = SubscriptionManager.isValidSubscriptionId(                    mUpdateMonitor.getNextSubIdForState(TelephonyManager.SIM_STATE_PERM_DISABLED));            final boolean lockedOrMissing = mUpdateMonitor.isSimPinSecure()                    || ((absent || disabled) && requireSim);             if (!lockedOrMissing && shouldWaitForProvisioning()) {                if (DEBUG) Log.d(TAG, "doKeyguard: not showing because device isn't provisioned"                        + " and the sim is not locked or missing");                return;            }             boolean forceShow = options != null && options.getBoolean(OPTION_FORCE_SHOW, false);            if (mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())                    && !lockedOrMissing && !forceShow) {                if (DEBUG) Log.d(TAG, "doKeyguard: not showing because lockscreen is off");                return;            }        }         if (DEBUG) Log.d(TAG, "doKeyguard: showing the lock screen");        showLocked(options);    }``    /**     * Send message to keyguard telling it to show itself     * @see #handleShow     */    private void showLocked(Bundle options) {        Trace.beginSection("KeyguardViewMediator#showLocked acquiring mShowKeyguardWakeLock");        if (DEBUG) Log.d(TAG, "showLocked");        // ensure we stay awake until we are finished displaying the keyguard        mShowKeyguardWakeLock.acquire();        Message msg = mHandler.obtainMessage(SHOW, options);        // Treat these messages with priority - This call can originate from #doKeyguardTimeout,        // meaning the device should lock as soon as possible and not wait for other messages on        // the thread to process first.        mHandler.sendMessageAtFrontOfQueue(msg);        Trace.endSection();    }``    /**     * Handle message sent by {@link #showLocked}.     * @see #SHOW     */    private void handleShow(Bundle options) {        Trace.beginSection("KeyguardViewMediator#handleShow");        final int currentUser = KeyguardUpdateMonitor.getCurrentUser();        if (mLockPatternUtils.isSecure(currentUser)) {            mLockPatternUtils.getDevicePolicyManager().reportKeyguardSecured(currentUser);        }        synchronized (KeyguardViewMediator.this) {            if (!mSystemReady) {                if (DEBUG) Log.d(TAG, "ignoring handleShow because system is not ready.");                return;            } else {                if (DEBUG) Log.d(TAG, "handleShow");            }             mHiding = false;            mKeyguardExitAnimationRunner = null;            mWakeAndUnlocking = false;            setPendingLock(false);            setShowingLocked(true);            mKeyguardViewControllerLazy.get().show(options);            resetKeyguardDonePendingLocked();            mHideAnimationRun = false;            adjustStatusBarLocked();            userActivity();            mUpdateMonitor.setKeyguardGoingAway(false);            mKeyguardViewControllerLazy.get().setKeyguardGoingAwayState(false);            mShowKeyguardWakeLock.release();        }        mKeyguardDisplayManager.show();         // schedule 4hr idle timeout after which non-strong biometrics (i.e. weak or convenience        // biometric) can't be used to unlock device until unlocking with strong biometric or        // primary auth (i.e. PIN/pattern/password)        mLockPatternUtils.scheduleNonStrongBiometricIdleTimeout(                KeyguardUpdateMonitor.getCurrentUser());         Trace.endSection();    }` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| showLockedmShowKeyguardWakeLock.acquire()：`private PowerManager.WakeLock mShowKeyguardWakeLock; private void setupLocked() {    mShowKeyguardWakeLock = mPM.newWakeLock(PowerManager.*PARTIAL_WAKE_LOCK*, "show keyguard");    mShowKeyguardWakeLock.setReferenceCounted(false);    ...    }`PowerManager.WakeLock也称作唤醒锁, 是一种保持 CPU 运转防止设备休眠的方式。在这里用到的是**`PARTIAL_WAKE_LOCK`****, 无论屏幕的状态甚至是用户按了电源钮, CPU 都会继续工作。**PARTIAL_WAKE_LOCK保持CPU运转，而屏幕可以处于OFF状态。在showLocked中，保持CPU处于运转状态直到锁屏显示。发送显示锁屏的消息，并放在队列最前面保证优先处理。 |                                                              |
| handleShow                                                   |                                                              |

## 三、Q&A

1. **SystemServer的启动**

学习文档：

[系统启动流程分析之system_server进程启动流程分析](https://juejin.cn/post/7061982428314730509#heading-0)

[Android系统启动流程之SystemServer进程启动](https://jsonchao.github.io/2019/03/03/Android系统启动流之SystemServer进程启动/)

动态调用到了SystemServer的main()
