---
title: View绘制流程详解
date: 2023-02-28 14:10:00 +0800
categories: [Blogging, Android, 源码分析]
tags: [Android]
img_path: /assets/img/view_draw/
render_with_liquid: false
---

大致流程图：
![图1](1.jpg)


详细流程图：

![图2](2.jpg)

> 从详细的流程图中就可以看出，**View的绘制是在Resume后开始。**
{: .prompt-tip }


可是在很多的博客或者Android教材中，都会告诉开发者们，**Activity的可见性变化是在onStart()生命周期发生的，可是此时view还没开始绘制，**那onStart()后Activity变为可见又如何解释呢？onStart()就可见，可onResume()后才绘制View，这是否矛盾呢？

以下第一部分将从Android源码解析onStart()、onResume()及Activity的可见和View绘制前的流程。

## 1. Activity生命周期与View绘制前

![图3](3.jpg)


通过打印需要的源码堆栈，我画出了上图。

这样就可以清晰地解释onStart()生命周期Activity变为可见：

### 1.1 onStart()与可见性

#### 1.1.1 ActivityThread#handleStartActivity

```java
@Override
public void handleStartActivity(ActivityClientRecord r,
        PendingTransactionActions pendingActions, ActivityOptions activityOptions) {
    final Activity activity = r.activity;
    if (!r.stopped) {
        throw new IllegalStateException("Can't start activity that is not stopped.");
    }
    if (r.activity.mFinished) {
        return;
    }

    unscheduleGcIdler();
    if (activityOptions != null) {
        activity.mPendingOptions = activityOptions;
    }

    // Start
    activity.performStart("handleStartActivity");
    r.setState(ON_START);

    if (pendingActions == null) {
        // No more work to do.
        return;
    }

    // Restore instance state
    if (pendingActions.shouldRestoreInstanceState()) {
        if (r.isPersistable()) {
            if (r.state != null || r.persistentState != null) {
                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,
                        r.persistentState);
            }
        } else if (r.state != null) {
            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
        }
    }

    // Call postOnCreate()
    if (pendingActions.shouldCallOnPostCreate()) {
        activity.mCalled = false;
        if (r.isPersistable()) {
            mInstrumentation.callActivityOnPostCreate(activity, r.state,
                    r.persistentState);
        } else {
            mInstrumentation.callActivityOnPostCreate(activity, r.state);
        }
        if (!activity.mCalled) {
            throw new SuperNotCalledException(
                    "Activity " + r.intent.getComponent().toShortString()
                            + " did not call through to super.onPostCreate()");
        }
    }

    updateVisibility(r, true /* show */);
    mSomeActivitiesChanged = true;
}
```

第18行调用了`activity.performStart("handleStartActivity");`，这个方法最终会调用到Activity的`onStart()`方法，而上述代码第54行调用了`updateVisibility(r, true /* show */);`，说明在`onStart()`后会更新Activity的可见性（即Activity开始可见）。
   
那Activity是如何变得可见？

#### 1.1.2 ActivityThread#updateVisibility

```java
private void updateVisibility(ActivityClientRecord r, boolean show) {
    View v = r.activity.mDecor;
    if (v != null) {
    // handleStartActivity中传进来的参数show为true
        if (show) {
            if (!r.activity.mVisibleFromServer) {
                r.activity.mVisibleFromServer = true;
                mNumVisibleActivities++;
                // 通过debug可得此时的r.activity.mVisibleFromClient为true, 
                // 所以r.activity.makeVisible();被执行
                if (r.activity.mVisibleFromClient) {
                    r.activity.makeVisible();
                }
            }
        } else {
            if (r.activity.mVisibleFromServer) {
                r.activity.mVisibleFromServer = false;
                mNumVisibleActivities--;
                v.setVisibility(View.INVISIBLE);
            }
        }
    }
}
```

#### 1.1.3 Activity#makeVisible

```java
void makeVisible() {
    if (!mWindowAdded) {
        ViewManager wm = getWindowManager();
        wm.addView(mDecor, getWindow().getAttributes());
        mWindowAdded = true;
    }
    mDecor.setVisibility(View.VISIBLE);
}
```

改变可见性的调用栈最终走到了`makeVisible`，这里可以确定DecorView会被添加到窗口中，并在最后一行使DecorView可见（View.VISIBLE），至此也可以说Activity可见了。

所以说Activity的可见和View的绘制并不矛盾，onStart()过程只是改变了DecorView的可见性，而绘制并没有开始。

### 1.2 onResume()与View绘制

onResume()后View才开始真正的绘制：
![图4](4.png)

#### 1.2.1 ActivityThread#handleResumeActivity

```java
    @Override
    public void handleResumeActivity(ActivityClientRecord r, boolean finalStateRequest,
        boolean isForward, boolean shouldSendCompatFakeFocus, String reason) {
        // ... ...省略部分源码
        if (!performResumeActivity(r, finalStateRequest, reason)) {
            return;
        }
        if (mActivitiesToBeDestroyed.containsKey(r.token)) {
            // Although the activity is resumed, it is going to be destroyed. So the following
            // UI operations are unnecessary and also prevents exception because its token may
            // be gone that window manager cannot recognize it. All necessary cleanup actions
            // performed below will be done while handling destruction.
            return;
        }
        final Activity a = r.activity;
        if (localLOGV) {
            Slog.v(TAG, "Resume " + r + " started activity: " + a.mStartedActivity
                    + ", hideForNow: " + r.hideForNow + ", finished: " + a.mFinished);
        }
        final int forwardBit = isForward
                ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
        // If the window hasn't yet been added to the window manager,
        // and this guy didn't finish itself or start another activity,
        // then go ahead and add the window.
        boolean willBeVisible = !a.mStartedActivity;
        if (!willBeVisible) {
            willBeVisible = ActivityClient.getInstance().willActivityBeVisible(
                    a.getActivityToken());
        }
        if (r.window == null && !a.mFinished && willBeVisible) {
            r.window = r.activity.getWindow();
            View decor = r.window.getDecorView();
            decor.setVisibility(View.INVISIBLE);
            ViewManager wm = a.getWindowManager();
            WindowManager.LayoutParams l = r.window.getAttributes();
            a.mDecor = decor;
            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
            l.softInputMode |= forwardBit;
            if (r.mPreserveWindow) {
                a.mWindowAdded = true;
                r.mPreserveWindow = false;
                // Normally the ViewRoot sets up callbacks with the Activity
                // in addView->ViewRootImpl#setView. If we are instead reusing
                // the decor view we have to notify the view root that the
                // callbacks may have changed.
                ViewRootImpl impl = decor.getViewRootImpl();
                if (impl != null) {
                    impl.notifyChildRebuilt();
                }
            }
            if (a.mVisibleFromClient) {
                if (!a.mWindowAdded) {
                    a.mWindowAdded = true;
                    wm.addView(decor, l);
                } else {
                    // The activity will get a callback for this {@link LayoutParams} change
                    // earlier. However, at that time the decor will not be set (this is set
                    // in this method), so no action will be taken. This call ensures the
                    // callback occurs with the decor set.
                    a.onWindowAttributesChanged(l);
                }
            }
            // If the window has already been added, but during resume
            // we started another activity, then don't yet make the
            // window visible.
        } else if (!willBeVisible) {
            if (localLOGV) Slog.v(TAG, "Launch " + r + " mStartedActivity set");
            r.hideForNow = true;
        }
    // ... ...省略部分源码
    }
```

在handleResumeActivity()中，performResumeActivity()先被执行，根据图3和下图时序可知performResumeActivity()最终会执行到Activity的onResume()：
![图5](5.png)

而`wm.addView(decor, l);`会在performResumeActivity()后执行，所以根据调用的顺序可知view绘制流程是在onResume()后开始。


#### 1.2.2 Resume 后、View绘制前

- WindowManagerImpl#addView

```java
@Override
public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
    applyTokens(params);
    mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,
            mContext.getUserId());
}
```

- WindowManagerGlobal#addView

```java
    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
// ... ... 省略部分代码
        ViewRootImpl root;
        View panelParentView = null;
// ... ... 省略部分代码
        // do this last because it fires off messages to start doing things
        try {
            root.setView(view, wparams, panelParentView);
        } catch (RuntimeException e) {
            // BadTokenException or InvalidDisplayException, clean up.
            synchronized (mLock) {
                final int index = findViewLocked(view, false);
                if (index >= 0) {
                    removeViewLocked(index, true);
                }
            }
            throw e;
        }
    }
```

这里传入的view都是DecorView，在`root.setView(view, wparams, panelParentView);`这里调用终于走到了ViewRootImpl，而ViewRootImpl会执行到performTraversals()，performTraversals()中会按顺序开始measure-layout-draw的调用：

![图6](6.png)

> **ActivityThread**
> This manages the execution of the main thread in an application process, scheduling and executing activities, broadcasts, and other operations on it as the activity manager requests.
在应用进程中管理主线程的执行，安排并执行activity和其它activity管理器请求的操作。
{: .prompt-info }


## 2. Measure - View测量

### 2.1 测量时序
![图7](7.png)

### 2.2 measure参数

```java
// android.view.View
public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
 // ... ...
}

protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 // ... ...
}
```

无论是measure()还是onMeasure()都有两个参数：`int widthMeasureSpec, int heightMeasureSpec`，这两个参数是View测量的规格，和MeasureSpec有关。

> `widthMeasureSpec`和`heightMeasureSpec`表示了父ViewGroup对自己View/ViewGroup的宽高的约束与期望。
{: .prompt-warning }

