---
title: View绘制流程详解
date: 2023-02-28 14:10:00 +0800
categories: [Blogging, Android, 源码分析]
tags: [Android, 源码分析]
img_path: /assets/img/view_draw/
render_with_liquid: false
---

大致流程图：
![图1](1.jpg)


详细流程图：

![图2](2.jpg)

> 从详细的流程图中就可以看出，**View的绘制是在Resume后开始。**
{: .prompt-tip }


可是在很多的博客或者Android教材中，都会告诉开发者们，**Activity的可见性变化是在onStart()生命周期发生的，可是此时view还没开始绘制，**那onStart()后Activity变为可见又如何解释呢？onStart()就可见，可onResume()后才绘制View，这是否矛盾呢？

以下第一部分将从Android源码解析onStart()、onResume()及Activity的可见和View绘制前的流程。

## 1. Activity生命周期与View绘制前

![图3](3.jpg)


通过打印需要的源码堆栈，我画出了上图。

这样就可以清晰地解释onStart()生命周期Activity变为可见：

### 1.1 onStart()与可见性

#### 1.1.1 ActivityThread#handleStartActivity

```java
@Override
public void handleStartActivity(ActivityClientRecord r,
        PendingTransactionActions pendingActions, ActivityOptions activityOptions) {
    final Activity activity = r.activity;
    if (!r.stopped) {
        throw new IllegalStateException("Can't start activity that is not stopped.");
    }
    if (r.activity.mFinished) {
        return;
    }

    unscheduleGcIdler();
    if (activityOptions != null) {
        activity.mPendingOptions = activityOptions;
    }

    // Start
    activity.performStart("handleStartActivity");
    r.setState(ON_START);

    if (pendingActions == null) {
        // No more work to do.
        return;
    }

    // Restore instance state
    if (pendingActions.shouldRestoreInstanceState()) {
        if (r.isPersistable()) {
            if (r.state != null || r.persistentState != null) {
                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,
                        r.persistentState);
            }
        } else if (r.state != null) {
            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
        }
    }

    // Call postOnCreate()
    if (pendingActions.shouldCallOnPostCreate()) {
        activity.mCalled = false;
        if (r.isPersistable()) {
            mInstrumentation.callActivityOnPostCreate(activity, r.state,
                    r.persistentState);
        } else {
            mInstrumentation.callActivityOnPostCreate(activity, r.state);
        }
        if (!activity.mCalled) {
            throw new SuperNotCalledException(
                    "Activity " + r.intent.getComponent().toShortString()
                            + " did not call through to super.onPostCreate()");
        }
    }

    updateVisibility(r, true /* show */);
    mSomeActivitiesChanged = true;
}
```

第18行调用了`activity.performStart("handleStartActivity");`，这个方法最终会调用到Activity的`onStart()`方法，而上述代码第54行调用了`updateVisibility(r, true /* show */);`，说明在`onStart()`后会更新Activity的可见性（即Activity开始可见）。

那Activity是如何变得可见？

#### 1.1.2 ActivityThread#updateVisibility

```java
private void updateVisibility(ActivityClientRecord r, boolean show) {
    View v = r.activity.mDecor;
    if (v != null) {
    // handleStartActivity中传进来的参数show为true
        if (show) {
            if (!r.activity.mVisibleFromServer) {
                r.activity.mVisibleFromServer = true;
                mNumVisibleActivities++;
                // 通过debug可得此时的r.activity.mVisibleFromClient为true, 
                // 所以r.activity.makeVisible();被执行
                if (r.activity.mVisibleFromClient) {
                    r.activity.makeVisible();
                }
            }
        } else {
            if (r.activity.mVisibleFromServer) {
                r.activity.mVisibleFromServer = false;
                mNumVisibleActivities--;
                v.setVisibility(View.INVISIBLE);
            }
        }
    }
}
```

#### 1.1.3 Activity#makeVisible

```java
void makeVisible() {
    if (!mWindowAdded) {
        ViewManager wm = getWindowManager();
        wm.addView(mDecor, getWindow().getAttributes());
        mWindowAdded = true;
    }
    mDecor.setVisibility(View.VISIBLE);
}
```

改变可见性的调用栈最终走到了`makeVisible`，这里可以确定DecorView会被添加到窗口中，并在最后一行使DecorView可见（View.VISIBLE），至此也可以说Activity可见了。

所以说Activity的可见和View的绘制并不矛盾，onStart()过程只是改变了DecorView的可见性，而绘制并没有开始。

### 1.2 onResume()与View绘制

onResume()后View才开始真正的绘制：
![图4](4.png)

#### 1.2.1 ActivityThread#handleResumeActivity

```java
    @Override
    public void handleResumeActivity(ActivityClientRecord r, boolean finalStateRequest,
        boolean isForward, boolean shouldSendCompatFakeFocus, String reason) {
        // ... ...省略部分源码
        if (!performResumeActivity(r, finalStateRequest, reason)) {
            return;
        }
        if (mActivitiesToBeDestroyed.containsKey(r.token)) {
            // Although the activity is resumed, it is going to be destroyed. So the following
            // UI operations are unnecessary and also prevents exception because its token may
            // be gone that window manager cannot recognize it. All necessary cleanup actions
            // performed below will be done while handling destruction.
            return;
        }
        final Activity a = r.activity;
        if (localLOGV) {
            Slog.v(TAG, "Resume " + r + " started activity: " + a.mStartedActivity
                    + ", hideForNow: " + r.hideForNow + ", finished: " + a.mFinished);
        }
        final int forwardBit = isForward
                ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
        // If the window hasn't yet been added to the window manager,
        // and this guy didn't finish itself or start another activity,
        // then go ahead and add the window.
        boolean willBeVisible = !a.mStartedActivity;
        if (!willBeVisible) {
            willBeVisible = ActivityClient.getInstance().willActivityBeVisible(
                    a.getActivityToken());
        }
        if (r.window == null && !a.mFinished && willBeVisible) {
            r.window = r.activity.getWindow();
            View decor = r.window.getDecorView();
            decor.setVisibility(View.INVISIBLE);
            ViewManager wm = a.getWindowManager();
            WindowManager.LayoutParams l = r.window.getAttributes();
            a.mDecor = decor;
            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
            l.softInputMode |= forwardBit;
            if (r.mPreserveWindow) {
                a.mWindowAdded = true;
                r.mPreserveWindow = false;
                // Normally the ViewRoot sets up callbacks with the Activity
                // in addView->ViewRootImpl#setView. If we are instead reusing
                // the decor view we have to notify the view root that the
                // callbacks may have changed.
                ViewRootImpl impl = decor.getViewRootImpl();
                if (impl != null) {
                    impl.notifyChildRebuilt();
                }
            }
            if (a.mVisibleFromClient) {
                if (!a.mWindowAdded) {
                    a.mWindowAdded = true;
                    wm.addView(decor, l);
                } else {
                    // The activity will get a callback for this {@link LayoutParams} change
                    // earlier. However, at that time the decor will not be set (this is set
                    // in this method), so no action will be taken. This call ensures the
                    // callback occurs with the decor set.
                    a.onWindowAttributesChanged(l);
                }
            }
            // If the window has already been added, but during resume
            // we started another activity, then don't yet make the
            // window visible.
        } else if (!willBeVisible) {
            if (localLOGV) Slog.v(TAG, "Launch " + r + " mStartedActivity set");
            r.hideForNow = true;
        }
    // ... ...省略部分源码
    }
```

在handleResumeActivity()中，performResumeActivity()先被执行，根据图3和下图时序可知performResumeActivity()最终会执行到Activity的onResume()：
![图5](5.png)

而`wm.addView(decor, l);`会在performResumeActivity()后执行，所以根据调用的顺序可知view绘制流程是在onResume()后开始。


#### 1.2.2 Resume 后、View绘制前

- WindowManagerImpl#addView

```java
@Override
public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
    applyTokens(params);
    mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,
            mContext.getUserId());
}
```

- WindowManagerGlobal#addView

```java
    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
// ... ... 省略部分代码
        ViewRootImpl root;
        View panelParentView = null;
        
        synchronized (mLock) {
        // ... ... 省略部分代码
// 所以Window的addView最终也是将view、view对应的ViewRootImpl、LayoutParams对象添加到列表中
            root = new ViewRootImpl(view.getContext(), display);
            view.setLayoutParams(wparams);
            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);
        }

        // do this last because it fires off messages to start doing things
        try {
            root.setView(view, wparams, panelParentView);
        } catch (RuntimeException e) {
            // BadTokenException or InvalidDisplayException, clean up.
            synchronized (mLock) {
                final int index = findViewLocked(view, false);
                if (index >= 0) {
                    removeViewLocked(index, true);
                }
            }
            throw e;
        }
    }
```

- `mViews.add(view); mRoots.add(root); mParams.add(wparams);`
  - mViews 中是 Window 所有的 View
  - mRoots 中是所有 View 对应的 ViewRootImpl
  - mParams 存储的是所有 View 所对应的LayoutParams
- `root.setView(view, wparams, panelParentView);`

这里传入的view都是DecorView，在`root.setView(view, wparams, panelParentView);`这里调用终于走到了ViewRootImpl，通过ViewRootImpl 来更新界面并完成View到Window的添加过程。

```java
// ViewRootImpl
public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,
        int userId) {
    synchronized (this) {
        if (mView == null) {
            mView = view;
         }
         // ... ...省略
            // Schedule the first layout -before- adding to the window
            // manager, to make sure we do the relayout before receiving
            // any other events from the system.
            requestLayout();
   // ... ...省略
    }
}

@Override
public void requestLayout() {
    if (!mHandlingLayoutInLayoutRequest) {
        if (ViewDebugManager.DEBUG_REQUESTLAYOUT) {
            Log.d(mTag, "requestLayout: mView = " + mView + ", this = " + this,
                    new Throwable("requestLayout"));
        }
        checkThread();
        mLayoutRequested = true;
        scheduleTraversals();
    }
}
```

`scheduleTraversals()`是 View 绘制的入口，而ViewRootImpl会执行到`performTraversals()`，`performTraversals()`中会按顺序开始measure-layout-draw的调用：

![图6](6.png)

> **ActivityThread**
> This manages the execution of the main thread in an application process, scheduling and executing activities, broadcasts, and other operations on it as the activity manager requests.
在应用进程中管理主线程的执行，安排并执行activity和其它activity管理器请求的操作。
{: .prompt-info }


## 2. Measure - View测量

### 2.1 测量时序
![图7](7.png)

### 2.2 measure参数

```java
// android.view.View
public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
 // ... ...
}

protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 // ... ...
}
```

无论是measure()还是onMeasure()都有两个参数：`int widthMeasureSpec, int heightMeasureSpec`，这两个参数是View测量的规格，和MeasureSpec有关。

> `widthMeasureSpec`和`heightMeasureSpec`表示了父ViewGroup对自己View/ViewGroup的宽高的约束与期望。
{: .prompt-warning }

// 未完待续......
## 3. Layout - View放置
![图8](8.png)
// 未完待续......
## 4. Draw - View绘制
![图9](9.png)
// 未完待续......



## 5. 关联类及组件

### 5.1 Window

android中所有视图都通过window呈现。单击事件由Window传递给DecorView，然后DecorView再传递给我们的View，就连Activity设置视图的方法setContentView底层也是通过Window来完成的。Window是一个抽象类，实现类有PhoneWindow。

### 5.2 ViewManager

用来给Activity添加、删除、更新子布局的接口。

```java
package android.view;

/** Interface to let you add and remove child views to an Activity. To get an instance
  * of this class, call {@link android.content.Context#getSystemService(java.lang.String) Context.getSystemService()}.
  */
public interface ViewManager
{
    /**
     * Assign the passed LayoutParams to the passed View and add the view to the window.
     * <p>Throws {@link android.view.WindowManager.BadTokenException} for certain programming
     * errors, such as adding a second view to a window without removing the first view.
     * <p>Throws {@link android.view.WindowManager.InvalidDisplayException} if the window is on a
     * secondary {@link Display} and the specified display can't be found
     * (see {@link android.app.Presentation}).
     * @param view The view to be added to this window.
     * @param params The LayoutParams to assign to view.
     */
    public void addView(View view, ViewGroup.LayoutParams params);
    public void updateViewLayout(View view, ViewGroup.LayoutParams params);
    public void removeView(View view);
}
```

### 5.3 WindowManager

继承ViewManager，用来管理Window操作的接口，还有一些窗口相关的flag（如窗口动画、窗口壁纸等）及方法。实现类是：`WindowManagerImpl`

### 5.4 WindowManagerImpl

是WindowManager的实现类，但是并没有View的添加、移除、更新具体操作，而是通过调用WindowManagerGlobal对象，实现View的添加、移除、更新。

```java
@Override
public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
    applyTokens(params);
    mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,
            mContext.getUserId());
}

@Override
public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
    applyTokens(params);
    mGlobal.updateViewLayout(view, params);
}

@Override
public void removeView(View view) {
    mGlobal.removeView(view, false);
}

@Override
public void removeViewImmediate(View view) {
    mGlobal.removeView(view, true);
}
```

### 5.5 WindowManagerGlobal

WindowManagerGlobal是一个全局静态单例类，一个进程中只有一个WindowManagerGlobal对象。它为无关任何特定context的操作提供与window manager的低级通信。此类仅在android内部用于实现全局方法。在WindowManagerGlobal内实现了addView、updateViewLayout、removeView。

### 5.6 ViewParent

定义了父级视图的职责/功能，如：clearChildFocus()、requestChildFocus()等，view可以通过ViewParent接口与其父View交互。

### 5.7 ViewRootImpl

ViewRootImpl 是 View 的最高层级，是所有 View 的根。ViewRootImpl 实现了 View 和 WindowManager 之间所需要的协议。ViewRootImpl 的创建过程是从 `WindowManagerImpl`开始的，实现了很多`WindowManagerGlobal`*的内部细节*。View 的测量，布局，绘制以及上屏，都是从 ViewRootImpl 中开始的。

